package com.example.spiel;

import javafx.animation.AnimationTimer;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Circle;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;

// Diese Klasse ist verantwortlich für die Spiellogik
public class GameManager {
    private Pane root;
    private ObjectUI objectUI;
    private AnimationTimer timer;
    private Scene scene;
    private OverlayUI overlayUI;
    private GameStats gameStats;
    private GameSounds gameSounds;
    private HashSet<KeyCode> activeKeys;
    private HighScoreManager highScoreManager = new HighScoreManager();
    private boolean highScoreDisplayed = false;
    double enemyX;
    double enemyY;
    double bossX;
    double bossY;

    public GameManager(Pane root, ObjectUI objectUI, Scene scene,
                       OverlayUI overlayUI, GameSounds gameSounds) {
        this.root = root;
        this.objectUI = objectUI;
        this.scene = scene;
        this.overlayUI = overlayUI;
        this.gameSounds = gameSounds;
        activeKeys = new HashSet<>();
    }

    void setGameStats(GameStats gameStats) {
        this.gameStats = gameStats;
    }

    //Hier werden alle Animationen pro Frame verwaltet
    void InitiateTimer() {
        timer = new AnimationTimer() {
            @Override
            public void handle(long now) {
                updateAttacks();
                updatePlayer();
                spawnEnemies();
                spawnBoss();
                updateEnemies();
                spawnBuff();
                updatePlayerStats();
            }
        };
        timer.start();
    }

    // Initialisiert und verwaltet die Angriffsobjekte
    void createAttack(MouseEvent event) {
        double playerX = objectUI.getPlayerView().getX() + objectUI.getPlayerView().getImage().getWidth() / 2;
        double playerY = objectUI.getPlayerView().getY() + objectUI.getPlayerView().getImage().getHeight() / 2;

        double mouseX = event.getSceneX();
        double mouseY = event.getSceneY();
        double angle = Math.atan2(mouseY - playerY, mouseX - playerX);
        double bulletSpeed = gameStats.getAttackSpeed() * 5.0;
        double bulletXSpeed = bulletSpeed * Math.cos(angle);
        double bulletYSpeed = bulletSpeed * Math.sin(angle);

        objectUI.createAttackView(playerX, playerY);

        objectUI.getAttackView().setUserData(new double[]{bulletXSpeed, bulletYSpeed});
    }

    //Diese Methode kuemmert sich um die Logik, wenn Angriffe Gegner treffen
    public void updateAttacks() {
        ArrayList<ImageView> bulletsToRemove = new ArrayList<>();
        ArrayList<ImageView> enemiesToRemove = new ArrayList<>();

        Iterator<ImageView> bulletIterator = objectUI.getAttackList().iterator();
        while (bulletIterator.hasNext()) {
            ImageView bullet = bulletIterator.next();
            double[] velocity = (double[]) bullet.getUserData();
            bullet.setX(bullet.getX() + velocity[0]);
            bullet.setY(bullet.getY() + velocity[1]);

            if (bullet.getX() < 0 || bullet.getX() > root.getWidth() ||
                    bullet.getY() < 0 || bullet.getY() > root.getHeight()) {
                bulletsToRemove.add(bullet);
            }

            Iterator<ImageView> enemyIterator = objectUI.getEnemies().iterator();
            while (enemyIterator.hasNext()) {
                ImageView enemyView = enemyIterator.next();
                //Entfernt den Gegner, wenn er getroffen wurde
                if (bullet.getBoundsInParent().intersects(enemyView.getBoundsInParent())) {
                    bulletsToRemove.add(bullet);
                    enemiesToRemove.add(enemyView);
                    //Erhoeht den Score wenn ein Gegner getroffen wurde
                    gameStats.setScore(gameStats.getScore() + 10);
                    overlayUI.setScore(gameStats.getScore());
                    overlayUI.setLevel(gameStats.level());
                }
                //
                if (gameStats.getEndBossSpawned()) {
                    if (bullet.getBoundsInParent().intersects(objectUI.getBossView().getBoundsInParent())) {
                        bulletsToRemove.add(bullet);
                        //Pro getroffenen Angriff wird das Leben des Bosses 1 niedriger
                        gameStats.decreaseHitPoints(1);
                        //Entfernt den Boss, wenn sein Leben 0 ist
                        if (gameStats.getBossHP() == 0) {
                            //Erhöht den Game-Score um 100 beim Töten des Bosses
                            gameStats.setScore(gameStats.getScore() + 100);
                            overlayUI.setScore(gameStats.getScore());
                            overlayUI.setLevel(gameStats.level());
                            gameStats.setEndBossKilled(true);
                            gameStats.setEndBossSpawned(false);
                            root.getChildren().remove(objectUI.getBossView());
                        }
                    }
                }
            }
        }
        objectUI.getAttackList().removeAll(bulletsToRemove);
        objectUI.getEnemies().removeAll(enemiesToRemove);
        root.getChildren().removeAll(bulletsToRemove);
        root.getChildren().removeAll(enemiesToRemove);
    }

    //Diese Methode generiert neue Gegner mit einer zufaelligen Position
    void spawnEnemies() {
        double spawnRate = (double) gameStats.level() / 200; //Spawnrate, angepasst an das Level

        //Erstellt einen neuen Gegner
        if (Math.random() < spawnRate) {
            do {
                enemyX = Math.random() * root.getWidth();
                enemyY = Math.random() * root.getHeight();
            } while (isTooCloseToPlayer(500));
            objectUI.createEnemyView(enemyX, enemyY);
        }
    }

    //Diese Methode kuemmert sich um die Gegnerlogik
    void updateEnemies() {
        Iterator<ImageView> enemyIterator = objectUI.getEnemies().iterator();
        while (enemyIterator.hasNext()) {
            ImageView enemy = enemyIterator.next();
            double playerX = objectUI.getPlayerView().getX();
            double playerY = objectUI.getPlayerView().getY();
            double enemyX = enemy.getX();
            double enemyY = enemy.getY();

            //Logik für die Bewegung des Gegners.
            double angle = Math.atan2(playerY - enemyY, playerX - enemyX);
            double speed = gameStats.level();
            double enemyXSpeed = speed * Math.cos(angle);
            double enemyYSpeed = speed * Math.sin(angle);
            //Setzt die Position des Gegners neu
            enemy.setX(enemyX + enemyXSpeed);
            enemy.setY(enemyY + enemyYSpeed);

            //Game-Over Logik, wenn der Gegner den Spieler erreicht
            if (objectUI.getPlayerView().getBoundsInParent().intersects(
                    //Passt die Hitbox an, wo die Gegner den Spieler erreichen
                    enemy.getBoundsInParent().getMinX(),
                    enemy.getBoundsInParent().getMinY() + 100,
                    enemy.getBoundsInParent().getWidth() - 40,
                    enemy.getBoundsInParent().getHeight() - 80)
                    || enemyX < 0 || enemyX > root.getWidth() || enemyY < 0 || enemyY > root.getHeight()) {
                enemyIterator.remove();
                root.getChildren().remove(enemy);
                deathStopGame();
            }
            if (gameStats.getScore() > highScoreManager.getHighestScore() && !highScoreDisplayed) {
                newHighScore();
            }
        }
    }

    void newHighScore() {
        ImageView highScoreView = new ImageView(new Image("file:src/main/resources/Otherstuff/highscore.png"));
        highScoreView.toBack();
        highScoreView.setX(700);
        highScoreView.setY(50);
        root.getChildren().add(highScoreView);

        Timeline timeline = new Timeline(
                new KeyFrame(Duration.seconds(3), e -> {
                    root.getChildren().remove(highScoreView);
                })
        );
        timeline.play();
        gameSounds.playHighScoreSound();
        highScoreDisplayed = true;
    }

    //Updated die Position des Spielers und stellt sicher, dass er im Bildschirm bleibt
    void updatePlayer() {
        scene.addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            activeKeys.add(event.getCode());
        });

        scene.addEventFilter(KeyEvent.KEY_RELEASED, event -> {
            activeKeys.remove(event.getCode());
        });

        if (!gameStats.getDeathState()) {
            double deltaX = 0;
            double deltaY = 0;

            if (activeKeys.contains(KeyCode.W)) {
                deltaY = -gameStats.getStep();
            }
            if (activeKeys.contains(KeyCode.S)) {
                deltaY = gameStats.getStep();
            }
            if (activeKeys.contains(KeyCode.A)) {
                deltaX = -gameStats.getStep();
            }
            if (activeKeys.contains(KeyCode.D)) {
                deltaX = gameStats.getStep();
            }
            objectUI.setBounds(deltaX, deltaY);
        }
    }

    //Spawnt den Boss bei Level 3
    void spawnBoss() {
        if (gameStats.level() == 3 && !gameStats.getEndBossSpawned() && !gameStats.getEndBossKilled()) {
            do {
                bossX = Math.random() * root.getWidth();
                bossY = Math.random() * root.getHeight();
            } while (isTooCloseToPlayer(1000));
            objectUI.createBossView(bossX, bossY);
            gameStats.setEndBossSpawned(true);
        }
        if (gameStats.getEndBossSpawned()) {
            updateBoss();
        }
    }

    //Verwaltet die Boss Logik.
    void updateBoss() {
        if (!gameStats.getEndBossKilled() && objectUI.getBossView() != null) {
            double playerX = objectUI.getPlayerView().getX();
            double playerY = objectUI.getPlayerView().getY();
            double bossX = objectUI.getBossView().getX();
            double bossY = objectUI.getBossView().getY();

            double angle = Math.atan2(playerY - bossY, playerX - bossX);
            double speed = gameStats.level();
            double bossXSpeed = speed * Math.cos(angle);
            double bossYSpeed = speed * Math.sin(angle);

            objectUI.getBossView().setX(bossX + bossXSpeed);
            objectUI.getBossView().setY(bossY + bossYSpeed);

            if (objectUI.getPlayerView().getBoundsInParent().intersects(
                    //Passt die Hitbox an, wo der Boss den Spieler erreicht
                    objectUI.getBossView().getBoundsInParent().getMinX() + 30,
                    objectUI.getBossView().getBoundsInParent().getMinY() + 10,
                    objectUI.getBossView().getBoundsInParent().getWidth() - 20,
                    objectUI.getBossView().getBoundsInParent().getHeight() - 20)
                    || bossX < 0 || bossX > root.getWidth() || bossY < 0 || bossY > root.getHeight()) {
                root.getChildren().remove(objectUI.getBossView());
                deathStopGame();
            }
        }
    }

    //Rotiert die Assets in Richtung der Maus
    public void rotateImageView(MouseEvent event, ImageView imageView) {
        if (!gameStats.getPaused()) {
            double playerX = imageView.getX() + imageView.getImage().getWidth() / 2;
            double playerY = imageView.getY() + imageView.getImage().getHeight() / 2;

            double mouseX = event.getSceneX();
            double mouseY = event.getSceneY();

            double angle = Math.toDegrees(Math.atan2(mouseY - playerY, mouseX - playerX));

            angle += 90;
            imageView.setRotate(angle);
        }
    }

    //Zeig den "Game-Over" Text, stoppt Musik, den timer und spielt den Todessound ab
    void deathStopGame() {
        overlayUI.showGameOverText(true);
        overlayUI.showRestartText(true);
        gameStats.setDeathState(true);

        // Speichert den Score fuer die High-Score Liste
        if (gameStats.getScore() != 0) {
            highScoreManager.addHighScore(gameStats.getScore());
            highScoreManager.saveHighScores();
        }

        highScoreDisplayed = false;
        timer.stop();
        gameSounds.stopMusic();
        gameSounds.playDeathSound();
    }

    //Updated die Schiessgeschwindigkeit
    void updatePlayerStats() {
        Iterator<ImageView> buffIterator = objectUI.getBuffList().iterator();
        while (buffIterator.hasNext()) {
            ImageView buff = buffIterator.next();

            double enemyX = buff.getX();
            double enemyY = buff.getY();


            buff.setX(enemyX);
            buff.setY(enemyY);

            if (objectUI.getPlayerView().getBoundsInParent().intersects(buff.getBoundsInParent()) ||
                    enemyX < 0 || enemyX > root.getWidth() || enemyY < 0 || enemyY > root.getHeight()) {
                buffIterator.remove();
                root.getChildren().remove(buff);
                gameStats.setAttackSpeed(gameStats.getAttackSpeed() + 0.5);
                gameStats.setStep(gameStats.getStep() + 0.5);
            }
        }
    }

    //Generiert eine neue Position des Gegners, sofern nicht zu nah an Spieler
    boolean isTooCloseToPlayer(double minDistance) {
        minDistance = 500.0; // Mindestabstand, an dem Gegner Spawnen dÃ¼rfen
        // Berechnet die Entfernung zwischen dem Spieler und dem potenziellen Ort, an dem der Feind spawnt
        double distance = Math.sqrt(Math.pow(objectUI.getPlayerView().getX() - enemyX, 2) + Math.pow(objectUI.getPlayerView().getY() - enemyY, 2));
        return distance < minDistance;
    }

    //Setzt die spawnrate und eine zufällige Position auf der Map
    void spawnBuff() {
        double spawnrate = 0.005;
        if (Math.random() < spawnrate) {
            double buffX = Math.random() * root.getWidth();
            double buffY = Math.random() * root.getHeight();
            objectUI.createBuffView(buffX, buffY);
        }
    }

    //Stoppt den Timer
    void stopTimer() {
        if (timer != null) {
            timer.stop();
        }
    }

    //Startet den Timer
    void startTimer() {
        if (timer != null) {
            timer.start();
        }
    }

    double getEnemyX() {
        return enemyX;
    }

    double getEnemyY() {
        return enemyY;
    }

    double getBossX() {
        return bossX;
    }

    double getBossY() {
        return bossY;
    }

    public Scene getScene() {
        return scene;
    }
}
