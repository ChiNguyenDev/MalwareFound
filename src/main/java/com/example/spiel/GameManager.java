package com.example.spiel;

import javafx.animation.AnimationTimer;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;

/**
 * The type Game manager.
 */
// Diese Klasse ist verantwortlich für die Spiellogik
public class GameManager {
    /**
     * The Root.
     */
    private Pane root;
    /**
     * The Entity ui.
     */
    private EntityUI entityUI;
    /**
     * The Timer.
     */
    private AnimationTimer timer;
    /**
     * The Scene.
     */
    private Scene scene;
    /**
     * The Overlay ui.
     */
    private OverlayUI overlayUI;
    /**
     * The Game stats.
     */
    private GameStats gameStats;
    /**
     * The Game sounds.
     */
    private GameSounds gameSounds;
    /**
     * The Active keys.
     */
    private HashSet<KeyCode> activeKeys;
    /**
     * The High score manager.
     */
    private HighScoreManager highScoreManager = new HighScoreManager();
    /**
     * The High score displayed.
     */
    private boolean highScoreDisplayed = false;
    /**
     * The Enemy x.
     */
    double enemyX;
    /**
     * The Enemy y.
     */
    double enemyY;
    /**
     * The Boss x.
     */
    double bossX;
    /**
     * The Boss y.
     */
    double bossY;

    /**
     * Instantiates a new Game manager.
     *
     * @param root       the root
     * @param entityUI   the entity ui
     * @param scene      the scene
     * @param overlayUI  the overlay ui
     * @param gameSounds the game sounds
     */
    public GameManager(Pane root, EntityUI entityUI, Scene scene,
                       OverlayUI overlayUI, GameSounds gameSounds) {
        this.root = root;
        this.entityUI = entityUI;
        this.scene = scene;
        this.overlayUI = overlayUI;
        this.gameSounds = gameSounds;
        activeKeys = new HashSet<>();
    }

    /**
     * Sets game stats.
     *
     * @param gameStats the game stats
     */
    void setGameStats(GameStats gameStats) {
        this.gameStats = gameStats;
    }

    /**
     * Initiate timer.
     */
// Hier werden alle Animationen pro Frame verwaltet
    void InitiateTimer() {
        timer = new AnimationTimer() {
            @Override
            public void handle(long now) {
                updateAttacks();
                updatePlayer();
                spawnEnemies();
                spawnBoss();
                updateEnemies();
                spawnBuff();
                updatePlayerStats();

            }
        };
        timer.start();
    }

    /**
     * Create attack.
     *
     * @param event the event
     */
// Initialisiert und verwaltet die Angriffsobjekte
    void createAttack(MouseEvent event) {
        double playerX = entityUI.getPlayerView().getX() + entityUI.getPlayerView().getImage().getWidth() / 2;
        double playerY = entityUI.getPlayerView().getY() + entityUI.getPlayerView().getImage().getHeight() / 2;

        double mouseX = event.getSceneX();
        double mouseY = event.getSceneY();
        double angle = Math.atan2(mouseY - playerY, mouseX - playerX);
        double bulletSpeed = gameStats.getAttackSpeed() * 5.0;
        double bulletXSpeed = bulletSpeed * Math.cos(angle);
        double bulletYSpeed = bulletSpeed * Math.sin(angle);

        entityUI.createAttackView(playerX, playerY, gameStats.getPaused());

        entityUI.getAttackView().setUserData(new double[]{bulletXSpeed, bulletYSpeed});
    }

    /**
     * Update attacks.
     */
// Diese Methode kümmert sich um die Logik, wenn Angriffe Gegner treffen
    public void updateAttacks() {
        ArrayList<ImageView> bulletsToRemove = new ArrayList<>();
        ArrayList<ImageView> enemiesToRemove = new ArrayList<>();

        Iterator<ImageView> bulletIterator = entityUI.getAttackList().iterator();
        while (bulletIterator.hasNext()) {
            ImageView bullet = bulletIterator.next();
            double[] velocity = (double[]) bullet.getUserData();
            bullet.setX(bullet.getX() + velocity[0]);
            bullet.setY(bullet.getY() + velocity[1]);

            // Löscht die Schüsse, wenn sie aus dem Bildschirm raus sind
            if (bullet.getX() < 0 || bullet.getX() > root.getWidth() ||
                    bullet.getY() < 0 || bullet.getY() > root.getHeight()) {
                bulletsToRemove.add(bullet);
            }

            Iterator<ImageView> enemyIterator = entityUI.getEnemies().iterator();
            while (enemyIterator.hasNext()) {
                ImageView enemyView = enemyIterator.next();

                // Erstellt Rechtecke, um die Hitboxen zu repräsentieren
                Rectangle bulletHitbox = new Rectangle(bullet.getX(), bullet.getY(), bullet.getBoundsInParent().getWidth(), bullet.getBoundsInParent().getHeight());
                Rectangle enemyHitbox = new Rectangle(enemyView.getX(), enemyView.getY(), enemyView.getBoundsInParent().getWidth(), enemyView.getBoundsInParent().getHeight());

                // Überprüfe auf Kollision mithilfe von Shape-Intersection
                Shape intersection = Shape.intersect(bulletHitbox, enemyHitbox);
                if (intersection.getBoundsInLocal().getWidth() != -1) {
                    // Kollision mit einem normalen Gegner erkannt
                    bulletsToRemove.add(bullet);
                    enemiesToRemove.add(enemyView);
                    gameStats.setScore(gameStats.getScore() + 10);
                    overlayUI.setScore(gameStats.getScore());
                    overlayUI.setLevel(gameStats.level());
                }
            }

            //Logik für das Abschießen des Bosses
            if (gameStats.getEndBossSpawned()) {
                Rectangle bulletRect = new Rectangle(bullet.getX(), bullet.getY(), bullet.getBoundsInParent().getWidth(), bullet.getBoundsInParent().getHeight());
                Rectangle bossRect = new Rectangle(entityUI.getBossView().getX(), entityUI.getBossView().getY(), entityUI.getBossView().getBoundsInParent().getWidth(), entityUI.getBossView().getBoundsInParent().getHeight());

                Shape intersection = Shape.intersect(bulletRect, bossRect);
                if (intersection.getBoundsInLocal().getWidth() != -1) {
                    // Kollision mit dem Boss erkannt
                    bulletsToRemove.add(bullet);

                    // Verringere die Lebenspunkte des Bosses
                    gameStats.decreaseHitPoints(1);

                    // Entferne den Boss, wenn seine Lebenspunkte 0 sind
                    if (gameStats.getBossHP() == 0) {
                        // Erhöhe den Spielpunktestand um 100 beim Töten des Bosses
                        gameStats.setScore(gameStats.getScore() + 100);
                        overlayUI.setScore(gameStats.getScore());
                        overlayUI.setLevel(gameStats.level());
                        gameStats.setEndBossKilled(true);
                        gameStats.setEndBossSpawned(false);
                        root.getChildren().remove(entityUI.getBossView());
                    }
                }
            }
        }

        entityUI.getAttackList().removeAll(bulletsToRemove);
        entityUI.getEnemies().removeAll(enemiesToRemove);
        root.getChildren().removeAll(bulletsToRemove);
        root.getChildren().removeAll(enemiesToRemove);
    }


    /**
     * Spawn enemies.
     */
// Diese Methode generiert neue Gegner mit einer zufälligen Position
    void spawnEnemies() {
        double spawnRate = (double) gameStats.level() / 80; //Spawnrate, angepasst an das Level

        //Erstellt einen neuen Gegner
        if (Math.random() < spawnRate) {
            do {
                enemyX = Math.random() * root.getWidth();
                enemyY = Math.random() * root.getHeight();
            } while (isTooCloseToPlayer(500, enemyX, enemyY));
            entityUI.createEnemyView(enemyX, enemyY);
        }
    }

    /**
     * Update enemies.
     */
// Diese Methode kümmert sich um die Gegnerlogik
    void updateEnemies() {
        Iterator<ImageView> enemyIterator = entityUI.getEnemies().iterator();
        while (enemyIterator.hasNext()) {
            ImageView enemy = enemyIterator.next();
            double playerX = entityUI.getPlayerView().getX();
            double playerY = entityUI.getPlayerView().getY();
            double enemyX = enemy.getX();
            double enemyY = enemy.getY();

            // Logik für die Bewegung des Gegners.
            double angle = Math.atan2(playerY - enemyY, playerX - enemyX);
            double speed = gameStats.level();
            double enemyXSpeed = speed * Math.cos(angle);
            double enemyYSpeed = speed * Math.sin(angle);
            // Setzt die Position des Gegners neu
            enemy.setX(enemyX + enemyXSpeed);
            enemy.setY(enemyY + enemyYSpeed);

            // Game-Over Logik, wenn der Gegner den Spieler erreicht
            Rectangle playerHitbox = new Rectangle(
                    entityUI.getPlayerView().getBoundsInParent().getMinX() + 50,
                    entityUI.getPlayerView().getBoundsInParent().getMinY() + 100,
                    entityUI.getPlayerView().getBoundsInParent().getWidth() - 100,
                    entityUI.getPlayerView().getBoundsInParent().getHeight() - 100
            );

            Rectangle enemyHitbox = new Rectangle(
                    enemy.getBoundsInParent().getMinX() + 10,
                    enemy.getBoundsInParent().getMinY() + 10,
                    enemy.getBoundsInParent().getWidth() - 20,
                    enemy.getBoundsInParent().getHeight() - 20
            );

            Shape intersection = Shape.intersect(playerHitbox, enemyHitbox);

            if (intersection.getBoundsInLocal().getWidth() != -1
                    || enemyX < 0 || enemyX > root.getWidth() || enemyY < 0 || enemyY > root.getHeight()) {
                enemyIterator.remove();
                root.getChildren().remove(enemy);
                deathStopGame();
            }

            if (gameStats.getScore() > highScoreManager.getHighestScore() && !highScoreDisplayed) {
                newHighScore();
            }
        }
    }

    /**
     * New high score.
     */
// Zeigt das Highscore Bild
    void newHighScore() {
        overlayUI.displayHighScoreView();
        gameSounds.playHighScoreSound();
        highScoreDisplayed = true;
    }

    /**
     * Update player.
     */
// Updated die Position des Spielers und stellt sicher, dass er im Bildschirm bleibt
    void updatePlayer() {
        // Fehlerbehebung, für den Fall, dass zwei Tasten gleichzeitig gedrückt werden
        scene.addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            activeKeys.add(event.getCode());
        });

        scene.addEventFilter(KeyEvent.KEY_RELEASED, event -> {
            activeKeys.remove(event.getCode());
        });

        // Logik für die Bewegung des Spielers
        if (!gameStats.getDeathState()) {
            double deltaX = 0;
            double deltaY = 0;

            if (activeKeys.contains(KeyCode.W)) {
                deltaY = -gameStats.getStep();
            }
            if (activeKeys.contains(KeyCode.S)) {
                deltaY = gameStats.getStep();
            }
            if (activeKeys.contains(KeyCode.A)) {
                deltaX = -gameStats.getStep();
            }
            if (activeKeys.contains(KeyCode.D)) {
                deltaX = gameStats.getStep();
            }
            entityUI.setBounds(deltaX, deltaY);
        }
    }

    /**
     * Spawn boss.
     */
// Spawnt den Boss bei Level 4
    void spawnBoss() {
        if (gameStats.level() == 4 && !gameStats.getEndBossSpawned() && !gameStats.getEndBossKilled()) {
            do {
                bossX = Math.random() * root.getWidth();
                bossY = Math.random() * root.getHeight();
            } while (isTooCloseToPlayer(500, bossX, bossY));
            entityUI.createBossView(bossX, bossY);
            gameStats.setEndBossSpawned(true);
        }

        // Logik für die Bewegung des Bosses
        if (gameStats.getEndBossSpawned() && entityUI.getBossView() != null) {
            updateBoss();
        }
    }

    /**
     * Update boss.
     */
// Verwaltet die Boss-Logik
    void updateBoss() {
        if (!gameStats.getEndBossKilled() && entityUI.getBossView() != null) {
            double playerX = entityUI.getPlayerView().getX();
            double playerY = entityUI.getPlayerView().getY();
            double bossX = entityUI.getBossView().getX();
            double bossY = entityUI.getBossView().getY();

            double angle = Math.atan2(playerY - bossY, playerX - bossX);
            double speed = gameStats.level();
            double bossXSpeed = speed * Math.cos(angle);
            double bossYSpeed = speed * Math.sin(angle);

            entityUI.getBossView().setX(bossX + bossXSpeed);
            entityUI.getBossView().setY(bossY + bossYSpeed);

            // Erstellen von Shapes für den Spieler und den Boss
            Rectangle playerShape = new Rectangle(
                    entityUI.getPlayerView().getBoundsInParent().getMinX() + 10,
                    entityUI.getPlayerView().getBoundsInParent().getMinY() + 20,
                    entityUI.getPlayerView().getBoundsInParent().getWidth() - 30,
                    entityUI.getPlayerView().getBoundsInParent().getHeight() - 30
            );

            Rectangle bossShape = new Rectangle(
                    entityUI.getBossView().getBoundsInParent().getMinX() + 10,
                    entityUI.getBossView().getBoundsInParent().getMinY() + 20,
                    entityUI.getBossView().getBoundsInParent().getWidth() - 30,
                    entityUI.getBossView().getBoundsInParent().getHeight() - 30
            );
            // Überprüfen, ob die Shapes kollidieren
            Shape collisionArea = Shape.intersect(playerShape, bossShape);

            if (collisionArea.getBoundsInLocal().getWidth() != -1
                    || bossX < 0 || bossX > root.getWidth() || bossY < 0 || bossY > root.getHeight()) {
                root.getChildren().remove(entityUI.getBossView());
                deathStopGame();
            }
        }
    }

    /**
     * Rotate image view.
     *
     * @param event     the event
     * @param imageView the image view
     */
// Rotiert die Assets in Richtung der Maus
    public void rotateImageView(MouseEvent event, ImageView imageView) {
        if (!gameStats.getPaused()) {
            double playerX = imageView.getX() + imageView.getImage().getWidth() / 2;
            double playerY = imageView.getY() + imageView.getImage().getHeight() / 2;

            double mouseX = event.getSceneX();
            double mouseY = event.getSceneY();

            double angle = Math.toDegrees(Math.atan2(mouseY - playerY, mouseX - playerX));

            //Rotiert das Spielerbild um 90 Grad, um es zum Cursor auszurichten
            angle += 90;
            imageView.setRotate(angle);
        }
    }

    /**
     * Death stop game.
     */
// Zeig den "Game-Over" Text, stoppt Musik, den timer und spielt den Todessound ab
    void deathStopGame() {
        //Zeigt des Todestext
        overlayUI.showGameOverText(true);
        overlayUI.showRestartText(true);
        gameStats.setDeathState(true);

        // Speichert den Score für die High-Score Liste
        if(gameStats.getScore() != 0) {
            highScoreManager.addHighScore(gameStats.getScore());
            highScoreManager.saveHighScores();
        }

        // Andere Todes-Logik
        highScoreDisplayed = false;
        timer.stop();
        gameSounds.stopMusic();
        gameSounds.playDeathSound();
    }

    /**
     * Update player stats.
     */
//Updated die Spieler-Werte beim Aufheben des Buffs
    void updatePlayerStats() {
        Iterator<ImageView> buffIterator = entityUI.getBuffList().iterator();
        while (buffIterator.hasNext()) {
            ImageView buff = buffIterator.next();

            double enemyX = buff.getX();
            double enemyY = buff.getY();

            buff.setX(enemyX);
            buff.setY(enemyY);

            //Kollisionslogik mit den Buff
            if (entityUI.getPlayerView().getBoundsInParent().intersects(buff.getBoundsInParent()) ||
                    enemyX < 0 || enemyX > root.getWidth() || enemyY < 0 || enemyY > root.getHeight()) {
                buffIterator.remove();
                root.getChildren().remove(buff);

                //Erhöht die Schieß - und allgemeine Geschwindigkeit des Spielers
                gameStats.setAttackSpeed(gameStats.getAttackSpeed() + 0.5);
                gameStats.setStep(gameStats.getStep() + 0.5);
            }
        }
    }

    /**
     * Is too close to player boolean.
     *
     * @param minDistance the min distance
     * @param entityX     the entity x
     * @param entityY     the entity y
     * @return the boolean
     */
//Generiert eine neue Position des Gegners, sofern nicht zu nah an Spieler
    boolean isTooCloseToPlayer(double minDistance, double entityX, double entityY) {
        // Berechnet die Entfernung zwischen dem Spieler und dem potenziellen Ort, an dem der Feind spawnt
        double distance = Math.sqrt(Math.pow(entityUI.getPlayerView().getX() - entityX, 2) + Math.pow(entityUI.getPlayerView().getY() - entityY, 2));
        return distance < minDistance;
    }

    /**
     * Spawn buff.
     */
//Setzt die Spawnrate und eine zufällige Position auf der Map
    void spawnBuff() {
        double spawnrate = 0.003;
        if (Math.random() < spawnrate) {
            double buffX = Math.random() * root.getWidth();
            double buffY = Math.random() * root.getHeight();
            entityUI.createBuffView(buffX, buffY);
        }
    }

    /**
     * Stop timer.
     */
//Stoppt den Timer
    void stopTimer() {
        if (timer != null) {
            timer.stop();
        }
    }

    /**
     * Start timer.
     */
//Startet den Timer
    void startTimer() {
        if (timer != null) {
            timer.start();
        }
    }

    /**
     * Gets enemy x.
     *
     * @return the enemy x
     */
    double getEnemyX() {
        return enemyX;
    }

    /**
     * Gets enemy y.
     *
     * @return the enemy y
     */
    double getEnemyY() {
        return enemyY;
    }

    /**
     * Gets boss x.
     *
     * @return the boss x
     */
    double getBossX() {
        return bossX;
    }

    /**
     * Gets boss y.
     *
     * @return the boss y
     */
    double getBossY() {
        return bossY;
    }

    /**
     * Gets scene.
     *
     * @return the scene
     */
    public Scene getScene() {
        return scene;
    }
}
